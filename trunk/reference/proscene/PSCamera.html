<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_16) on Sun Feb 28 10:23:05 COT 2010 -->
<TITLE>
PSCamera (Javadocs: proscene)
</TITLE>

<META NAME="date" CONTENT="2010-02-28">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="PSCamera (Javadocs: proscene)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../proscene/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../proscene/PSAxisPlaneConstraint.Type.html" title="enum in proscene"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../proscene/PSCamera.Type.html" title="enum in proscene"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?proscene/PSCamera.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="PSCamera.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
proscene</FONT>
<BR>
Class PSCamera</H2>
<PRE>
java.lang.Object
  <IMG SRC="../resources/inherit.gif" ALT="extended by "><B>proscene.PSCamera</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.lang.Cloneable</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>PSCamera</B><DT>extends java.lang.Object<DT>implements java.lang.Cloneable</DL>
</PRE>

<P>
A perspective or orthographic camera.
 <p>
 A PSCamera defines some intrinsic parameters (<A HREF="../proscene/PSCamera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A>,
 <A HREF="../proscene/PSCamera.html#position()"><CODE>position()</CODE></A>, <A HREF="../proscene/PSCamera.html#viewDirection()"><CODE>viewDirection()</CODE></A>, <A HREF="../proscene/PSCamera.html#upVector()"><CODE>upVector()</CODE></A>...)
 and useful positioning tools that ease its placement
 (<A HREF="../proscene/PSCamera.html#showEntireScene()"><CODE>showEntireScene()</CODE></A>, <A HREF="../proscene/PSCamera.html#fitSphere(processing.core.PVector, float)"><CODE>fitSphere(PVector, float)</CODE></A>,
 <A HREF="../proscene/PSCamera.html#lookAt(processing.core.PVector)"><CODE>lookAt(PVector)</CODE></A>...). It exports its associated projection and
 modelview matrices and can interactively be modified using the mouse.
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.Type.html" title="enum in proscene">PSCamera.Type</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enumerates the two possible types of Camera.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../proscene/PSCamera.html#PSCamera()">PSCamera</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default constructor.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#aspectRatio()">aspectRatio</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the PSCamera aspect ratio defined by <A HREF="../proscene/PSCamera.html#screenWidth()"><CODE>screenWidth()</CODE></A> /
 <A HREF="../proscene/PSCamera.html#screenHeight()"><CODE>screenHeight()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;processing.core.PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#at()">at</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a point defined in the world coordinate system where the camera is
 pointing at (just in front of <A HREF="../proscene/PSCamera.html#viewDirection()"><CODE>viewDirection()</CODE></A>).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;processing.core.PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#cameraCoordinatesOf(processing.core.PVector)">cameraCoordinatesOf</A></B>(processing.core.PVector&nbsp;src)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the PSCamera frame coordinates of a point <code>src</code> defined in
 world coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#centerScene()">centerScene</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves the PSCamera so that its <A HREF="../proscene/PSCamera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A> is projected on the
 center of the window.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../proscene/PSCamera.html" title="class in proscene">PSCamera</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#clone()">clone</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation of the clone method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#computeModelViewMatrix()">computeModelViewMatrix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the modelView matrix associated with the Camera's <A HREF="../proscene/PSCamera.html#position()"><CODE>position()</CODE></A>
 and <A HREF="../proscene/PSCamera.html#orientation()"><CODE>orientation()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#computeProjectionMatrix()">computeProjectionMatrix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the projection matrix associated with the PSCamera.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#convertClickToLine(java.awt.Point, processing.core.PVector, processing.core.PVector)">convertClickToLine</A></B>(java.awt.Point&nbsp;pixelInput,
                   processing.core.PVector&nbsp;orig,
                   processing.core.PVector&nbsp;dir)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gives the coefficients of a 3D half-line passing through the PSCamera eye
 and pixel (x,y).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#distanceToSceneCenter()">distanceToSceneCenter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the distance from the Camera center to <A HREF="../proscene/PSCamera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A>, projected
 along the Camera Z axis.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#fieldOfView()">fieldOfView</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the vertical field of view of the PSCamera (in radians).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#fitBoundingBox(processing.core.PVector, processing.core.PVector)">fitBoundingBox</A></B>(processing.core.PVector&nbsp;min,
               processing.core.PVector&nbsp;max)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves the PSCamera so that the (world axis aligned) bounding box (<code>min</code>, <code>max</code>) is entirely visible, using
 <A HREF="../proscene/PSCamera.html#fitSphere(processing.core.PVector, float)"><CODE>fitSphere(PVector, float)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#fitScreenRegion(java.awt.Rectangle)">fitScreenRegion</A></B>(java.awt.Rectangle&nbsp;rectangle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves the PSCamera so that the rectangular screen region defined by <code>rectangle</code> (pixel units, with origin in the upper left corner) fits the
 screen.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#fitSphere(processing.core.PVector, float)">fitSphere</A></B>(processing.core.PVector&nbsp;center,
          float&nbsp;radius)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves the PSCamera so that the sphere defined by <code>center</code>, <code>radius</code>) is visible and fits the window.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#flySpeed()">flySpeed</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the fly speed of the PSCamera.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#focusDistance()">focusDistance</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the focus distance used by stereo display, expressed in processing
 units.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../proscene/PSInteractiveCameraFrame.html" title="class in proscene">PSInteractiveCameraFrame</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#frame()">frame</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the PSInteractiveCameraFrame attached to the PSCamera.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;processing.core.PMatrix3D</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#getModelViewMatrix()">getModelViewMatrix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience function that simply returns
 <code>return getModelViewMatrix(new PMatrix3D())</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;processing.core.PMatrix3D</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#getModelViewMatrix(processing.core.PMatrix3D)">getModelViewMatrix</A></B>(processing.core.PMatrix3D&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills <code>m</code> with the Camera modelView matrix values and returns it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#getOrthoWidthHeight()">getOrthoWidthHeight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience function that simply returns <code>getOrthoWidthHeight(new
 float[2])</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#getOrthoWidthHeight(float[])">getOrthoWidthHeight</A></B>(float[]&nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills in <code>target</code> with the <code>halfWidth</code> and <code>halfHeight</code>
 of the PSCamera orthographic frustum and returns it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;processing.core.PMatrix3D</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#getProjectionMatrix()">getProjectionMatrix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience function that simply returns <code>return return getProjectionMatrix(new PMatrix3D())</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;processing.core.PMatrix3D</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#getProjectionMatrix(processing.core.PMatrix3D)">getProjectionMatrix</A></B>(processing.core.PMatrix3D&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills <code>m</code> with the PSCamera projection matrix values and returns it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#getViewport()">getViewport</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience function that simply calls <code>return</code>
 <A HREF="../proscene/PSCamera.html#getViewport(int[])"><CODE>getViewport(int[])</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#getViewport(int[])">getViewport</A></B>(int[]&nbsp;viewport)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills <code>viewport</code> with the PSCamera viewport and returns it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#horizontalFieldOfView()">horizontalFieldOfView</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the horizontal field of view of the PSCamera (in radians).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#IODistance()">IODistance</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the user's inter-ocular distance (in meters).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#lookAt(processing.core.PVector)">lookAt</A></B>(processing.core.PVector&nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the PSCamera <A HREF="../proscene/PSCamera.html#orientation()"><CODE>orientation()</CODE></A>, so that it looks at point
 <code>target</code> (defined in the world coordinate system).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../proscene/PSQuaternion.html" title="class in proscene">PSQuaternion</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#orientation()">orientation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the PSCamera orientation, defined in the world coordinate system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#physicalDistanceToScreen()">physicalDistanceToScreen</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the physical distance between the user's eyes and the screen (in
 meters).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#physicalScreenWidth()">physicalScreenWidth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the physical screen width, in meters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#pixelPSRatio(processing.core.PVector)">pixelPSRatio</A></B>(processing.core.PVector&nbsp;position)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the ratio between pixel and processing scene units at <code>position</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;processing.core.PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#position()">position</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the PSCamera position (the eye), defined in the world coordinate
 system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;processing.core.PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#projectedCoordinatesOf(processing.core.PVector)">projectedCoordinatesOf</A></B>(processing.core.PVector&nbsp;src)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience function that simply returns <code>return
 projectedCoordinatesOf(src, null)</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;processing.core.PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#projectedCoordinatesOf(processing.core.PVector, proscene.PSFrame)">projectedCoordinatesOf</A></B>(processing.core.PVector&nbsp;src,
                       <A HREF="../proscene/PSFrame.html" title="class in proscene">PSFrame</A>&nbsp;frame)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the screen projected coordinates of a point <code>src</code> defined
 in the <code>frame</code> coordinate system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;processing.core.PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#revolveAroundPoint()">revolveAroundPoint</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The point the PSCamera revolves around its
 <A HREF="../proscene/PSInteractiveCameraFrame.html#revolveAroundPoint()"><CODE>PSInteractiveCameraFrame.revolveAroundPoint()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;processing.core.PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#rightVector()">rightVector</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the normalized right vector of the PSCamera, defined in the world
 coordinate system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;processing.core.PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#sceneCenter()">sceneCenter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the position of the scene center, defined in the world coordinate
 system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#sceneRadius()">sceneRadius</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the radius of the scene observed by the Camera.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#screenHeight()">screenHeight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the height (in pixels) of the PSCamera screen.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#screenWidth()">screenWidth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the width (in pixels) of the PSCamera screen.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setAspectRatio(float)">setAspectRatio</A></B>(float&nbsp;aspect)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defines the PSCamera <A HREF="../proscene/PSCamera.html#aspectRatio()"><CODE>aspectRatio()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setCoordinateSystemLeftHanded()">setCoordinateSystemLeftHanded</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wrapper function that simply calls
 <code>frame().setCoordinateSystemConvention(CoordinateSystemConvention.LEFT_HANDED)</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setCoordinateSystemRightHanded()">setCoordinateSystemRightHanded</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wrapper function that simply calls
 <code>frame().setCoordinateSystemConvention(CoordinateSystemConvention.RIGHT_HANDED)</code></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setFieldOfView(float)">setFieldOfView</A></B>(float&nbsp;fov)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the vertical <A HREF="../proscene/PSCamera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A> of the PSCamera (in radians).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setFlySpeed(float)">setFlySpeed</A></B>(float&nbsp;speed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the PSCamera <A HREF="../proscene/PSCamera.html#flySpeed()"><CODE>flySpeed()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setFocusDistance(float)">setFocusDistance</A></B>(float&nbsp;distance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the focusDistance(), in processing scene units.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setFOVToFitScene()">setFOVToFitScene</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Changes the PSCamera <A HREF="../proscene/PSCamera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A> so that the entire scene
 (defined by <A HREF="../proscene/PScene.html#sceneCenter()"><CODE>PScene.sceneCenter()</CODE></A> and
 <A HREF="../proscene/PScene.html#sceneRadius()"><CODE>PScene.sceneRadius()</CODE></A> is visible from the PSCamera
 <A HREF="../proscene/PSCamera.html#position()"><CODE>position()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setFrame(proscene.PSInteractiveCameraFrame)">setFrame</A></B>(<A HREF="../proscene/PSInteractiveCameraFrame.html" title="class in proscene">PSInteractiveCameraFrame</A>&nbsp;icf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the PSCamera <A HREF="../proscene/PSCamera.html#frame()"><CODE>frame()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setHorizontalFieldOfView(float)">setHorizontalFieldOfView</A></B>(float&nbsp;hfov)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <A HREF="../proscene/PSCamera.html#horizontalFieldOfView()"><CODE>horizontalFieldOfView()</CODE></A> of the PSCamera (in radians).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setIODistance(float)">setIODistance</A></B>(float&nbsp;distance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <A HREF="../proscene/PSCamera.html#IODistance()"><CODE>IODistance()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setModelViewMatrix(processing.core.PMatrix3D)">setModelViewMatrix</A></B>(processing.core.PMatrix3D&nbsp;modelview)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the modelview matrix associated with the PSCamera directly from a PCamera.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setOrientation(float, float)">setOrientation</A></B>(float&nbsp;theta,
               float&nbsp;phi)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <A HREF="../proscene/PSCamera.html#orientation()"><CODE>orientation()</CODE></A> of the PSCamera using polar coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setOrientation(proscene.PSQuaternion)">setOrientation</A></B>(<A HREF="../proscene/PSQuaternion.html" title="class in proscene">PSQuaternion</A>&nbsp;q)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the PSCamera <A HREF="../proscene/PSCamera.html#orientation()"><CODE>orientation()</CODE></A>, defined in the world coordinate
 system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setPhysicalDistanceToScreen(float)">setPhysicalDistanceToScreen</A></B>(float&nbsp;distance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <A HREF="../proscene/PSCamera.html#physicalDistanceToScreen()"><CODE>physicalDistanceToScreen()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setPhysicalScreenWidth(float)">setPhysicalScreenWidth</A></B>(float&nbsp;width)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the physical screen (monitor or projected wall) width (in meters).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setPosition(processing.core.PVector)">setPosition</A></B>(processing.core.PVector&nbsp;pos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the PSCamera <A HREF="../proscene/PSCamera.html#position()"><CODE>position()</CODE></A> (the eye), defined in the world
 coordinate system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setProjectionMatrix(processing.core.PMatrix3D)">setProjectionMatrix</A></B>(processing.core.PMatrix3D&nbsp;proj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the projection matrix associated with the PSCamera directly from a PCamera.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setRevolveAroundPoint(processing.core.PVector)">setRevolveAroundPoint</A></B>(processing.core.PVector&nbsp;rap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Changes the <A HREF="../proscene/PSCamera.html#revolveAroundPoint()"><CODE>revolveAroundPoint()</CODE></A> to <code>rap</code> (defined in the
 world coordinate system).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setSceneBoundingBox(processing.core.PVector, processing.core.PVector)">setSceneBoundingBox</A></B>(processing.core.PVector&nbsp;min,
                    processing.core.PVector&nbsp;max)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Similar to <A HREF="../proscene/PSCamera.html#setSceneRadius(float)"><CODE>setSceneRadius(float)</CODE></A> and
 <A HREF="../proscene/PSCamera.html#setSceneCenter(processing.core.PVector)"><CODE>setSceneCenter(PVector)</CODE></A>, but the scene limits are defined by a
 (world axis aligned) bounding box.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setSceneCenter(processing.core.PVector)">setSceneCenter</A></B>(processing.core.PVector&nbsp;center)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <A HREF="../proscene/PSCamera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setSceneRadius(float)">setSceneRadius</A></B>(float&nbsp;radius)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <A HREF="../proscene/PSCamera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setScreenWidthAndHeight(int, int)">setScreenWidthAndHeight</A></B>(int&nbsp;width,
                        int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets PSCamera <A HREF="../proscene/PSCamera.html#screenWidth()"><CODE>screenWidth()</CODE></A> and <A HREF="../proscene/PSCamera.html#screenHeight()"><CODE>screenHeight()</CODE></A>
 (expressed in pixels).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setType(proscene.PSCamera.Type)">setType</A></B>(<A HREF="../proscene/PSCamera.Type.html" title="enum in proscene">PSCamera.Type</A>&nbsp;type)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defines the PSCamera <A HREF="../proscene/PSCamera.html#type()"><CODE>type()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setUpVector(processing.core.PVector)">setUpVector</A></B>(processing.core.PVector&nbsp;up)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience function that simply calls <code>setUpVector(up, true)</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setUpVector(processing.core.PVector, boolean)">setUpVector</A></B>(processing.core.PVector&nbsp;up,
            boolean&nbsp;noMove)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotates the PSCamera so that its <A HREF="../proscene/PSCamera.html#upVector()"><CODE>upVector()</CODE></A> becomes <code>up</code>
 (defined in the world coordinate system).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setViewDirection(processing.core.PVector)">setViewDirection</A></B>(processing.core.PVector&nbsp;direction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotates the PSCamera so that its <A HREF="../proscene/PSCamera.html#viewDirection()"><CODE>viewDirection()</CODE></A> is <code>direction</code> (defined in the world coordinate system).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setZClippingCoefficient(float)">setZClippingCoefficient</A></B>(float&nbsp;coef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <A HREF="../proscene/PSCamera.html#zClippingCoefficient()"><CODE>zClippingCoefficient()</CODE></A> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#setZNearCoefficient(float)">setZNearCoefficient</A></B>(float&nbsp;coef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <A HREF="../proscene/PSCamera.html#zNearCoefficient()"><CODE>zNearCoefficient()</CODE></A> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#showEntireScene()">showEntireScene</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves the PSCamera so that the entire scene is visible.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../proscene/PSCamera.Type.html" title="enum in proscene">PSCamera.Type</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#type()">type</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the PSCamera.Type of the PSCamera.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;processing.core.PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#upVector()">upVector</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the normalized up vector of the PSCamera, defined in the world
 coordinate system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;processing.core.PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#viewDirection()">viewDirection</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the normalized view direction of the PSCamera, defined in the
 world coordinate system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;processing.core.PVector</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#worldCoordinatesOf(processing.core.PVector)">worldCoordinatesOf</A></B>(processing.core.PVector&nbsp;src)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the world coordinates of the point whose position <code>src</code> is
 defined in the PSCamera coordinate system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#zClippingCoefficient()">zClippingCoefficient</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the coefficient used to position the near and far clipping
 planes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#zFar()">zFar</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the far clipping plane distance used by the Camera projection
 matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#zNear()">zNear</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the near clipping plane distance used by the PSCamera projection
 matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../proscene/PSCamera.html#zNearCoefficient()">zNearCoefficient</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the coefficient which is used to set <A HREF="../proscene/PSCamera.html#zNear()"><CODE>zNear()</CODE></A> when the
 PSCamera is inside the sphere defined by <A HREF="../proscene/PSCamera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A> and
 <A HREF="../proscene/PSCamera.html#zClippingCoefficient()"><CODE>zClippingCoefficient()</CODE></A> * <A HREF="../proscene/PSCamera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A>.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="PSCamera()"><!-- --></A><H3>
PSCamera</H3>
<PRE>
public <B>PSCamera</B>()</PRE>
<DL>
<DD>Default constructor. 
 <p> 
 <A HREF="../proscene/PSCamera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A> is set to (0,0,0) and <A HREF="../proscene/PSCamera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> is
 set to 1.0. <A HREF="../proscene/PSCamera.html#type()"><CODE>type()</CODE></A> PSCamera.PERSPECTIVE, with a <code>PI/4</code>
 <A HREF="../proscene/PSCamera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A>. 
 <p> 
 See <A HREF="../proscene/PSCamera.html#IODistance()"><CODE>IODistance()</CODE></A>, <A HREF="../proscene/PSCamera.html#physicalDistanceToScreen()"><CODE>physicalDistanceToScreen()</CODE></A>,
 <A HREF="../proscene/PSCamera.html#physicalScreenWidth()"><CODE>physicalScreenWidth()</CODE></A> and <A HREF="../proscene/PSCamera.html#focusDistance()"><CODE>focusDistance()</CODE></A>
 documentations for default stereo parameter values.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="clone()"><!-- --></A><H3>
clone</H3>
<PRE>
public <A HREF="../proscene/PSCamera.html" title="class in proscene">PSCamera</A> <B>clone</B>()</PRE>
<DL>
<DD>Implementation of the clone method. 
 <p> 
 Calls <A HREF="../proscene/PSFrame.html#clone()"><CODE>PSFrame.clone()</CODE></A> and makes a deep
 copy of the remaining object attributes except for
 <code>prevConstraint</code> (which is shallow copied).
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>clone</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../proscene/PSFrame.html#clone()"><CODE>PSFrame.clone()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="position()"><!-- --></A><H3>
position</H3>
<PRE>
public final processing.core.PVector <B>position</B>()</PRE>
<DL>
<DD>Returns the PSCamera position (the eye), defined in the world coordinate
 system. 
 <p> 
 Use <A HREF="../proscene/PSCamera.html#setPosition(processing.core.PVector)"><CODE>setPosition(PVector)</CODE></A> to set the Camera position. Other
 convenient methods are showEntireScene() or fitSphere(). Actually returns
 <A HREF="../proscene/PSFrame.html#position()"><CODE>PSFrame.position()</CODE></A>. 
 <p> 
 This position corresponds to the projection center of a
 PSCamera.PERSPECTIVE camera. It is not located in the image plane, which
 is at a zNear() distance ahead.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setPosition(processing.core.PVector)"><!-- --></A><H3>
setPosition</H3>
<PRE>
public void <B>setPosition</B>(processing.core.PVector&nbsp;pos)</PRE>
<DL>
<DD>Sets the PSCamera <A HREF="../proscene/PSCamera.html#position()"><CODE>position()</CODE></A> (the eye), defined in the world
 coordinate system.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="upVector()"><!-- --></A><H3>
upVector</H3>
<PRE>
public processing.core.PVector <B>upVector</B>()</PRE>
<DL>
<DD>Returns the normalized up vector of the PSCamera, defined in the world
 coordinate system. 
 <p> 
 Set using <A HREF="../proscene/PSCamera.html#setUpVector(processing.core.PVector)"><CODE>setUpVector(PVector)</CODE></A> or <A HREF="../proscene/PSCamera.html#setOrientation(proscene.PSQuaternion)"><CODE>setOrientation(PSQuaternion)</CODE></A>.
 It is orthogonal to <A HREF="../proscene/PSCamera.html#viewDirection()"><CODE>viewDirection()</CODE></A> and to <A HREF="../proscene/PSCamera.html#rightVector()"><CODE>rightVector()</CODE></A>. 
 <p> 
 It corresponds to the Y axis of the associated <A HREF="../proscene/PSCamera.html#frame()"><CODE>frame()</CODE></A> (actually returns
 <A HREF="../proscene/PSFrame.html#inverseTransformOf(processing.core.PVector)"><CODE>PSFrame.inverseTransformOf(PVector)</CODE></A>)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUpVector(processing.core.PVector)"><!-- --></A><H3>
setUpVector</H3>
<PRE>
public void <B>setUpVector</B>(processing.core.PVector&nbsp;up)</PRE>
<DL>
<DD>Convenience function that simply calls <code>setUpVector(up, true)</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../proscene/PSCamera.html#setUpVector(processing.core.PVector, boolean)"><CODE>setUpVector(PVector, boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setUpVector(processing.core.PVector, boolean)"><!-- --></A><H3>
setUpVector</H3>
<PRE>
public void <B>setUpVector</B>(processing.core.PVector&nbsp;up,
                        boolean&nbsp;noMove)</PRE>
<DL>
<DD>Rotates the PSCamera so that its <A HREF="../proscene/PSCamera.html#upVector()"><CODE>upVector()</CODE></A> becomes <code>up</code>
 (defined in the world coordinate system). 
 <p> 
 The PSCamera is rotated around an axis orthogonal to <code>up</code> and to
 the current <A HREF="../proscene/PSCamera.html#upVector()"><CODE>upVector()</CODE></A> direction. 
 <p> 
 Use this method in order to define the PSCamera horizontal plane.
 <p> 
 When <code>noMove</code> is set to <code>false</code>, the orientation modification
 is compensated by a translation, so that the
 <A HREF="../proscene/PSCamera.html#revolveAroundPoint()"><CODE>revolveAroundPoint()</CODE></A> stays projected at the same position on
 screen. This is especially useful when the PSCamera is an observer of the
 scene (default mouse binding). 
 <p> 
 When <code>noMove</code> is true, the PSCamera <A HREF="../proscene/PSCamera.html#position()"><CODE>position()</CODE></A> is left
 unchanged, which is an intuitive behavior when the PSCamera is in a
 walkthrough fly mode.
 
 See also setViewDirection(), lookAt() and setOrientation().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="viewDirection()"><!-- --></A><H3>
viewDirection</H3>
<PRE>
public processing.core.PVector <B>viewDirection</B>()</PRE>
<DL>
<DD>Returns the normalized view direction of the PSCamera, defined in the
 world coordinate system. 
 <p> 
 Change this value using <A HREF="../proscene/PSCamera.html#setViewDirection(processing.core.PVector)"><CODE>setViewDirection(PVector)</CODE></A>, <A HREF="../proscene/PSCamera.html#lookAt(processing.core.PVector)"><CODE>lookAt(PVector)</CODE></A>
 or <A HREF="../proscene/PSCamera.html#setOrientation(proscene.PSQuaternion)"><CODE>setOrientation(PSQuaternion)</CODE></A>. It is orthogonal to <A HREF="../proscene/PSCamera.html#upVector()"><CODE>upVector()</CODE></A> and
 to <A HREF="../proscene/PSCamera.html#rightVector()"><CODE>rightVector()</CODE></A>.
 <p> 
 This corresponds to the negative Z axis of the <A HREF="../proscene/PSCamera.html#frame()"><CODE>frame()</CODE></A> ( <code>frame().inverseTransformOf(new PVector(0.0f, 0.0f, -1.0f))</code> ).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setViewDirection(processing.core.PVector)"><!-- --></A><H3>
setViewDirection</H3>
<PRE>
public void <B>setViewDirection</B>(processing.core.PVector&nbsp;direction)</PRE>
<DL>
<DD>Rotates the PSCamera so that its <A HREF="../proscene/PSCamera.html#viewDirection()"><CODE>viewDirection()</CODE></A> is <code>direction</code> (defined in the world coordinate system). 
 <p> 
 The PSCamera <A HREF="../proscene/PSCamera.html#position()"><CODE>position()</CODE></A> is not modified. The PSCamera is rotated
 so that the horizon (defined by its <A HREF="../proscene/PSCamera.html#upVector()"><CODE>upVector()</CODE></A>) is preserved.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../proscene/PSCamera.html#lookAt(processing.core.PVector)"><CODE>lookAt(PVector)</CODE></A>, 
<A HREF="../proscene/PSCamera.html#setUpVector(processing.core.PVector)"><CODE>setUpVector(PVector)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="rightVector()"><!-- --></A><H3>
rightVector</H3>
<PRE>
public processing.core.PVector <B>rightVector</B>()</PRE>
<DL>
<DD>Returns the normalized right vector of the PSCamera, defined in the world
 coordinate system. 
 <p> 
 This vector lies in the PSCamera horizontal plane, directed along the X
 axis (orthogonal to <A HREF="../proscene/PSCamera.html#upVector()"><CODE>upVector()</CODE></A> and to <A HREF="../proscene/PSCamera.html#viewDirection()"><CODE>viewDirection()</CODE></A>.
 Set using <A HREF="../proscene/PSCamera.html#setUpVector(processing.core.PVector)"><CODE>setUpVector(PVector)</CODE></A>, <A HREF="../proscene/PSCamera.html#lookAt(processing.core.PVector)"><CODE>lookAt(PVector)</CODE></A> or
 <A HREF="../proscene/PSCamera.html#setOrientation(proscene.PSQuaternion)"><CODE>setOrientation(PSQuaternion)</CODE></A>.
 <p> 
 Simply returns <code>frame().inverseTransformOf(new PVector(1.0f, 0.0f,
 0.0f))</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="orientation()"><!-- --></A><H3>
orientation</H3>
<PRE>
public <A HREF="../proscene/PSQuaternion.html" title="class in proscene">PSQuaternion</A> <B>orientation</B>()</PRE>
<DL>
<DD>Returns the PSCamera orientation, defined in the world coordinate system.
 <p> 
 Actually returns <code>frame().orientation()</code>. 
 Use <A HREF="../proscene/PSCamera.html#setOrientation(proscene.PSQuaternion)"><CODE>setOrientation(PSQuaternion)</CODE></A>, <A HREF="../proscene/PSCamera.html#setUpVector(processing.core.PVector)"><CODE>setUpVector(PVector)</CODE></A>
 or <A HREF="../proscene/PSCamera.html#lookAt(processing.core.PVector)"><CODE>lookAt(PVector)</CODE></A> to set the PSCamera orientation.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setOrientation(float, float)"><!-- --></A><H3>
setOrientation</H3>
<PRE>
public void <B>setOrientation</B>(float&nbsp;theta,
                           float&nbsp;phi)</PRE>
<DL>
<DD>Sets the <A HREF="../proscene/PSCamera.html#orientation()"><CODE>orientation()</CODE></A> of the PSCamera using polar coordinates. 
 <p> 
 <code>theta</code> rotates the PSCamera around its Y axis, and then <code>phi</code> rotates it around its X axis. 
 <p> 
 The polar coordinates are defined in the world coordinates system:
 <code>theta = phi = 0</code> means that the PSCamera is directed towards the
 world Z axis. Both angles are expressed in radians.
 <p> 
 The <A HREF="../proscene/PSCamera.html#position()"><CODE>position()</CODE></A> of the PSCamera is unchanged, you may want to call
 <A HREF="../proscene/PSCamera.html#showEntireScene()"><CODE>showEntireScene()</CODE></A> after this method to move the PSCamera.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../proscene/PSCamera.html#setUpVector(processing.core.PVector)"><CODE>setUpVector(PVector)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setOrientation(proscene.PSQuaternion)"><!-- --></A><H3>
setOrientation</H3>
<PRE>
public void <B>setOrientation</B>(<A HREF="../proscene/PSQuaternion.html" title="class in proscene">PSQuaternion</A>&nbsp;q)</PRE>
<DL>
<DD>Sets the PSCamera <A HREF="../proscene/PSCamera.html#orientation()"><CODE>orientation()</CODE></A>, defined in the world coordinate
 system.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setCoordinateSystemLeftHanded()"><!-- --></A><H3>
setCoordinateSystemLeftHanded</H3>
<PRE>
public void <B>setCoordinateSystemLeftHanded</B>()</PRE>
<DL>
<DD>Wrapper function that simply calls
 <code>frame().setCoordinateSystemConvention(CoordinateSystemConvention.LEFT_HANDED)</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setCoordinateSystemRightHanded()"><!-- --></A><H3>
setCoordinateSystemRightHanded</H3>
<PRE>
public void <B>setCoordinateSystemRightHanded</B>()</PRE>
<DL>
<DD>Wrapper function that simply calls
 <code>frame().setCoordinateSystemConvention(CoordinateSystemConvention.RIGHT_HANDED)</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="type()"><!-- --></A><H3>
type</H3>
<PRE>
public final <A HREF="../proscene/PSCamera.Type.html" title="enum in proscene">PSCamera.Type</A> <B>type</B>()</PRE>
<DL>
<DD>Returns the PSCamera.Type of the PSCamera. 
 <p> 
 Set by <A HREF="../proscene/PSCamera.html#setType(proscene.PSCamera.Type)"><CODE>setType(Type)</CODE></A>. 
 <p> 
 A <A HREF="../proscene/PSCamera.Type.html#PERSPECTIVE"><CODE>PSCamera.Type.PERSPECTIVE</CODE></A> PSCamera uses a classical projection
 mainly defined by its <A HREF="../proscene/PSCamera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A>. 
 <p> 
 With a <A HREF="../proscene/PSCamera.Type.html#ORTHOGRAPHIC"><CODE>PSCamera.Type.ORTHOGRAPHIC</CODE></A> <A HREF="../proscene/PSCamera.html#type()"><CODE>type()</CODE></A>, the <A HREF="../proscene/PSCamera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A> is
 meaningless and the width and height of the PSCamera frustum are inferred
 from the distance to the <A HREF="../proscene/PSCamera.html#revolveAroundPoint()"><CODE>revolveAroundPoint()</CODE></A> using
 <A HREF="../proscene/PSCamera.html#getOrthoWidthHeight()"><CODE>getOrthoWidthHeight()</CODE></A>. 
 <p> 
 Both types use <A HREF="../proscene/PSCamera.html#zNear()"><CODE>zNear()</CODE></A> and <A HREF="../proscene/PSCamera.html#zFar()"><CODE>zFar()</CODE></A> (to define their
 clipping planes) and <A HREF="../proscene/PSCamera.html#aspectRatio()"><CODE>aspectRatio()</CODE></A> (for frustum shape).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setType(proscene.PSCamera.Type)"><!-- --></A><H3>
setType</H3>
<PRE>
public final void <B>setType</B>(<A HREF="../proscene/PSCamera.Type.html" title="enum in proscene">PSCamera.Type</A>&nbsp;type)</PRE>
<DL>
<DD>Defines the PSCamera <A HREF="../proscene/PSCamera.html#type()"><CODE>type()</CODE></A>. 
 <p> 
 Changing the PSCamera Type alters the viewport and the objects' size can
 be changed. This method guarantees that the two frustum match in a plane
 normal to <A HREF="../proscene/PSCamera.html#viewDirection()"><CODE>viewDirection()</CODE></A>, passing through the Revolve Around
 Point (RAP).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="fieldOfView()"><!-- --></A><H3>
fieldOfView</H3>
<PRE>
public float <B>fieldOfView</B>()</PRE>
<DL>
<DD>Returns the vertical field of view of the PSCamera (in radians). 
 <p> 
 Value is set using <A HREF="../proscene/PSCamera.html#setFieldOfView(float)"><CODE>setFieldOfView(float)</CODE></A>. Default value is pi/4
 radians. This value is meaningless if the PSCamera <A HREF="../proscene/PSCamera.html#type()"><CODE>type()</CODE></A> is
 <A HREF="../proscene/PSCamera.Type.html#ORTHOGRAPHIC"><CODE>PSCamera.Type.ORTHOGRAPHIC</CODE></A>. 
 <p> 
 The field of view corresponds the one used in <code>gluPerspective</code> (see
 manual). It sets the Y (vertical) aperture of the PSCamera. The X
 (horizontal) angle is inferred from the window aspect ratio (see
 <A HREF="../proscene/PSCamera.html#aspectRatio()"><CODE>aspectRatio()</CODE></A> and <A HREF="../proscene/PSCamera.html#horizontalFieldOfView()"><CODE>horizontalFieldOfView()</CODE></A>).
 <p> 
 Use <A HREF="../proscene/PSCamera.html#setFOVToFitScene()"><CODE>setFOVToFitScene()</CODE></A> to adapt the <A HREF="../proscene/PSCamera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A>
 to a given scene.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setFieldOfView(float)"><!-- --></A><H3>
setFieldOfView</H3>
<PRE>
public void <B>setFieldOfView</B>(float&nbsp;fov)</PRE>
<DL>
<DD>Sets the vertical <A HREF="../proscene/PSCamera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A> of the PSCamera (in radians). 
 <p> 
 Note that <A HREF="../proscene/PSCamera.html#focusDistance()"><CODE>focusDistance()</CODE></A> is set to <A HREF="../proscene/PSCamera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> /
 tan( <A HREF="../proscene/PSCamera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A>/2) by this method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setFOVToFitScene()"><!-- --></A><H3>
setFOVToFitScene</H3>
<PRE>
public void <B>setFOVToFitScene</B>()</PRE>
<DL>
<DD>Changes the PSCamera <A HREF="../proscene/PSCamera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A> so that the entire scene
 (defined by <A HREF="../proscene/PScene.html#sceneCenter()"><CODE>PScene.sceneCenter()</CODE></A> and
 <A HREF="../proscene/PScene.html#sceneRadius()"><CODE>PScene.sceneRadius()</CODE></A> is visible from the PSCamera
 <A HREF="../proscene/PSCamera.html#position()"><CODE>position()</CODE></A>. 
 <p> 
 The <A HREF="../proscene/PSCamera.html#position()"><CODE>position()</CODE></A> and <A HREF="../proscene/PSCamera.html#orientation()"><CODE>orientation()</CODE></A> of the PSCamera are
 not modified and you first have to orientate the PSCamera in order to
 actually see the scene (see <A HREF="../proscene/PSCamera.html#lookAt(processing.core.PVector)"><CODE>lookAt(PVector)</CODE></A>,
 <A HREF="../proscene/PSCamera.html#showEntireScene()"><CODE>showEntireScene()</CODE></A> or <A HREF="../proscene/PSCamera.html#fitSphere(processing.core.PVector, float)"><CODE>fitSphere(PVector, float)</CODE></A>). 
 <p> 
 This method is especially useful for <i>shadow maps</i> computation. Use
 the PSCamera positioning tools (<A HREF="../proscene/PSCamera.html#setPosition(processing.core.PVector)"><CODE>setPosition(PVector)</CODE></A>,
 <A HREF="../proscene/PSCamera.html#lookAt(processing.core.PVector)"><CODE>lookAt(PVector)</CODE></A>) to position a PSCamera at the light position.
 Then use this method to define the <A HREF="../proscene/PSCamera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A> so that the
 shadow map resolution is optimally used: 
 <p> 
 <code>// The light camera needs size hints in order to optimize its
 fieldOfView</code> <br>
 <code>lightCamera.setSceneRadius(sceneRadius());</code> <br>
 <code>lightCamera.setSceneCenter(sceneCenter());</code> <br>
 <code>// Place the light camera</code> <br>
 <code>lightCamera.setPosition(lightFrame.position());</code> <br>
 <code>lightCamera.lookAt(sceneCenter());</code> <br>
 <code>lightCamera.setFOVToFitScene();</code> <br>
 <p> 
 <b>Attention:</b> The <A HREF="../proscene/PSCamera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A> is clamped to M_PI/2.0. This
 happens when the PSCamera is at a distance lower than sqrt(2.0) *
 sceneRadius() from the sceneCenter(). It optimizes the shadow map
 resolution, although it may miss some parts of the scene.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getOrthoWidthHeight()"><!-- --></A><H3>
getOrthoWidthHeight</H3>
<PRE>
public float[] <B>getOrthoWidthHeight</B>()</PRE>
<DL>
<DD>Convenience function that simply returns <code>getOrthoWidthHeight(new
 float[2])</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getOrthoWidthHeight(float[])"><!-- --></A><H3>
getOrthoWidthHeight</H3>
<PRE>
public float[] <B>getOrthoWidthHeight</B>(float[]&nbsp;target)</PRE>
<DL>
<DD>Fills in <code>target</code> with the <code>halfWidth</code> and <code>halfHeight</code>
 of the PSCamera orthographic frustum and returns it. 
 <p> 
 While <code>target[0]</code> holds <code>halfWidth</code>, <code>target[1]</code> holds
 <code>halfHeight</code>. 
 <p> 
 These values are only valid and used when the PSCamera is of <A HREF="../proscene/PSCamera.html#type()"><CODE>type()</CODE></A>
 ORTHOGRAPHIC and they are expressed in processing scene units.
 <p> 
 These values are proportional to the PSCamera (z projected) distance to
 the <A HREF="../proscene/PSCamera.html#revolveAroundPoint()"><CODE>revolveAroundPoint()</CODE></A>. When zooming on the object, the
 PSCamera is translated forward \e and its frustum is narrowed, making the
 object appear bigger on screen, as intuitively expected. 
 <p> 
 Overload this method to change this behavior if desired.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="horizontalFieldOfView()"><!-- --></A><H3>
horizontalFieldOfView</H3>
<PRE>
public float <B>horizontalFieldOfView</B>()</PRE>
<DL>
<DD>Returns the horizontal field of view of the PSCamera (in radians). 
 <p> 
 Value is set using <A HREF="../proscene/PSCamera.html#setHorizontalFieldOfView(float)"><CODE>setHorizontalFieldOfView(float)</CODE></A> or
 <A HREF="../proscene/PSCamera.html#setFieldOfView(float)"><CODE>setFieldOfView(float)</CODE></A>. These values are always linked by:
 <code>horizontalFieldOfView() = 2.0 * atan ( tan(fieldOfView()/2.0) *
 aspectRatio() )</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setHorizontalFieldOfView(float)"><!-- --></A><H3>
setHorizontalFieldOfView</H3>
<PRE>
public void <B>setHorizontalFieldOfView</B>(float&nbsp;hfov)</PRE>
<DL>
<DD>Sets the <A HREF="../proscene/PSCamera.html#horizontalFieldOfView()"><CODE>horizontalFieldOfView()</CODE></A> of the PSCamera (in radians). 
 <p> 
 <A HREF="../proscene/PSCamera.html#horizontalFieldOfView()"><CODE>horizontalFieldOfView()</CODE></A> and <A HREF="../proscene/PSCamera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A> are linked by
 the <A HREF="../proscene/PSCamera.html#aspectRatio()"><CODE>aspectRatio()</CODE></A>. This method actually calls <code>setFieldOfView(( 2.0 * atan (tan(hfov / 2.0) / aspectRatio()) ))</code> so that
 a call to <A HREF="../proscene/PSCamera.html#horizontalFieldOfView()"><CODE>horizontalFieldOfView()</CODE></A> returns the expected value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="aspectRatio()"><!-- --></A><H3>
aspectRatio</H3>
<PRE>
public float <B>aspectRatio</B>()</PRE>
<DL>
<DD>Returns the PSCamera aspect ratio defined by <A HREF="../proscene/PSCamera.html#screenWidth()"><CODE>screenWidth()</CODE></A> /
 <A HREF="../proscene/PSCamera.html#screenHeight()"><CODE>screenHeight()</CODE></A>. 
 <p> 
 When the PSCamera is attached to a PSCene, these values and hence the
 aspectRatio() are automatically fitted to the viewer's window aspect
 ratio using setScreenWidthAndHeight().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setAspectRatio(float)"><!-- --></A><H3>
setAspectRatio</H3>
<PRE>
public void <B>setAspectRatio</B>(float&nbsp;aspect)</PRE>
<DL>
<DD>Defines the PSCamera <A HREF="../proscene/PSCamera.html#aspectRatio()"><CODE>aspectRatio()</CODE></A>. 
 <p> 
 This value is actually inferred from the <A HREF="../proscene/PSCamera.html#screenWidth()"><CODE>screenWidth()</CODE></A> /
 <A HREF="../proscene/PSCamera.html#screenHeight()"><CODE>screenHeight()</CODE></A> ratio. You should use
 <A HREF="../proscene/PSCamera.html#setScreenWidthAndHeight(int, int)"><CODE>setScreenWidthAndHeight(int, int)</CODE></A> instead. 
 <p> 
 This method might however be convenient when the PSCamera is not
 associated with a PScene. It actually sets the
 <A HREF="../proscene/PSCamera.html#screenHeight()"><CODE>screenHeight()</CODE></A> to 100 and the <A HREF="../proscene/PSCamera.html#screenWidth()"><CODE>screenWidth()</CODE></A>
 accordingly. See also <A HREF="../proscene/PSCamera.html#setFOVToFitScene()"><CODE>setFOVToFitScene()</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setScreenWidthAndHeight(int, int)"><!-- --></A><H3>
setScreenWidthAndHeight</H3>
<PRE>
public void <B>setScreenWidthAndHeight</B>(int&nbsp;width,
                                    int&nbsp;height)</PRE>
<DL>
<DD>Sets PSCamera <A HREF="../proscene/PSCamera.html#screenWidth()"><CODE>screenWidth()</CODE></A> and <A HREF="../proscene/PSCamera.html#screenHeight()"><CODE>screenHeight()</CODE></A>
 (expressed in pixels). 
 <p> 
 You should not call this method when the PSCamera is associated with a
 PScene, since the latter automatically updates these values when it
 is resized (hence overwriting your values). 
 <p> 
 Non-positive dimension are silently replaced by a 1 pixel value to ensure
 frustrum coherence. 
 <p> 
 If your PSCamera is used without a PScene (offscreen rendering,
 shadow maps), use <A HREF="../proscene/PSCamera.html#setAspectRatio(float)"><CODE>setAspectRatio(float)</CODE></A> instead to define the
 projection matrix.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="screenWidth()"><!-- --></A><H3>
screenWidth</H3>
<PRE>
public final int <B>screenWidth</B>()</PRE>
<DL>
<DD>Returns the width (in pixels) of the PSCamera screen. 
 <p> 
 Set using <A HREF="../proscene/PSCamera.html#setScreenWidthAndHeight(int, int)"><CODE>setScreenWidthAndHeight(int, int)</CODE></A>. This value is automatically fitted
 to the PScene's window dimensions when the PSCamera is attached to a PScene.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="screenHeight()"><!-- --></A><H3>
screenHeight</H3>
<PRE>
public final int <B>screenHeight</B>()</PRE>
<DL>
<DD>Returns the height (in pixels) of the PSCamera screen. 
 <p> 
 Set using <A HREF="../proscene/PSCamera.html#setScreenWidthAndHeight(int, int)"><CODE>setScreenWidthAndHeight(int, int)</CODE></A>. This value is automatically fitted
 to the PScene's window dimensions when the PSCamera is attached to a PScene.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getViewport()"><!-- --></A><H3>
getViewport</H3>
<PRE>
public int[] <B>getViewport</B>()</PRE>
<DL>
<DD>Convenience function that simply calls <code>return</code>
 <A HREF="../proscene/PSCamera.html#getViewport(int[])"><CODE>getViewport(int[])</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getViewport(int[])"><!-- --></A><H3>
getViewport</H3>
<PRE>
public int[] <B>getViewport</B>(int[]&nbsp;viewport)</PRE>
<DL>
<DD>Fills <code>viewport</code> with the PSCamera viewport and returns it.
 If viewport is null (or not the correct size), a new array will be
 created. 
 <p>
 This method is mainly used in conjunction with <code>gluProject</code>, which
 requires such a viewport. Returned values are (0, <A HREF="../proscene/PSCamera.html#screenHeight()"><CODE>screenHeight()</CODE></A>,
 <A HREF="../proscene/PSCamera.html#screenWidth()"><CODE>screenWidth()</CODE></A>, -<A HREF="../proscene/PSCamera.html#screenHeight()"><CODE>screenHeight()</CODE></A>), so that the origin is located in the
 upper left corner of the window.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="zNear()"><!-- --></A><H3>
zNear</H3>
<PRE>
public float <B>zNear</B>()</PRE>
<DL>
<DD>Returns the near clipping plane distance used by the PSCamera projection
 matrix. 
 <p> 
 The clipping planes' positions depend on the <A HREF="../proscene/PSCamera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> and
 <A HREF="../proscene/PSCamera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A> rather than being fixed small-enough and
 large-enough values. A good scene dimension approximation will hence
 result in an optimal precision of the z-buffer. 
 <p> 
 The near clipping plane is positioned at a distance equal to
 <A HREF="../proscene/PSCamera.html#zClippingCoefficient()"><CODE>zClippingCoefficient()</CODE></A> * <A HREF="../proscene/PSCamera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> in front of the
 <A HREF="../proscene/PSCamera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A>: <code>distanceToSceneCenter() -
 zClippingCoefficient() * sceneRadius()</code> 
 <p> 
 In order to prevent negative or too small <A HREF="../proscene/PSCamera.html#zNear()"><CODE>zNear()</CODE></A> values (which would
 degrade the z precision), <A HREF="../proscene/PSCamera.html#zNearCoefficient()"><CODE>zNearCoefficient()</CODE></A> is used when the
 PSCamera is inside the <A HREF="../proscene/PSCamera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> sphere:
 <p>
 <code>zMin = zNearCoefficient() * zClippingCoefficient() *
 sceneRadius();</code><br>
 <code>zNear = zMin;</code><br>
 <code>// With an ORTHOGRAPHIC type, the value is simply clamped to 0.0</code>
 <br> 
 <p> 
 See also the <A HREF="../proscene/PSCamera.html#zFar()"><CODE>zFar()</CODE></A>, <A HREF="../proscene/PSCamera.html#zClippingCoefficient()"><CODE>zClippingCoefficient()</CODE></A> and
 <A HREF="../proscene/PSCamera.html#zNearCoefficient()"><CODE>zNearCoefficient()</CODE></A> documentations. 
 <p> 
 If you need a completely different zNear computation, overload the
 <A HREF="../proscene/PSCamera.html#zNear()"><CODE>zNear()</CODE></A> and <A HREF="../proscene/PSCamera.html#zFar()"><CODE>zFar()</CODE></A> methods in a new class that publicly inherits from
 Camera and use <A HREF="../proscene/PScene.html#setCamera(proscene.PSCamera)"><CODE>PScene.setCamera(PSCamera)</CODE></A>. 
 <p> 
 <b>Attention:</b> The value is always positive although the clipping
 plane is positioned at a negative z value in the Camera coordinate
 system. This follows the <code>gluPerspective</code> standard.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="zFar()"><!-- --></A><H3>
zFar</H3>
<PRE>
public float <B>zFar</B>()</PRE>
<DL>
<DD>Returns the far clipping plane distance used by the Camera projection
 matrix. 
 <p> 
 The far clipping plane is positioned at a distance equal to <code>zClippingCoefficient() * sceneRadius()</code> behind the <A HREF="../proscene/PSCamera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A>:
 <p>
 <code>zFar = distanceToSceneCenter() +
 zClippingCoefficient()*sceneRadius();</code><br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../proscene/PSCamera.html#zNear()"><CODE>zNear()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="zNearCoefficient()"><!-- --></A><H3>
zNearCoefficient</H3>
<PRE>
public float <B>zNearCoefficient</B>()</PRE>
<DL>
<DD>Returns the coefficient which is used to set <A HREF="../proscene/PSCamera.html#zNear()"><CODE>zNear()</CODE></A> when the
 PSCamera is inside the sphere defined by <A HREF="../proscene/PSCamera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A> and
 <A HREF="../proscene/PSCamera.html#zClippingCoefficient()"><CODE>zClippingCoefficient()</CODE></A> * <A HREF="../proscene/PSCamera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A>. 
 <p> 
 In that case, the <A HREF="../proscene/PSCamera.html#zNear()"><CODE>zNear()</CODE></A> value is set to <code>zNearCoefficient() * zClippingCoefficient() * sceneRadius()</code>. See the
 <code>zNear()</code> documentation for details. 
 <p> 
 Default value is 0.005, which is appropriate for most applications. In
 case you need a high dynamic ZBuffer precision, you can increase this
 value (~0.1). A lower value will prevent clipping of very close objects
 at the expense of a worst Z precision. 
 <p> 
 Only meaningful when PSCamera type is PERSPECTIVE.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setZNearCoefficient(float)"><!-- --></A><H3>
setZNearCoefficient</H3>
<PRE>
public void <B>setZNearCoefficient</B>(float&nbsp;coef)</PRE>
<DL>
<DD>Sets the <A HREF="../proscene/PSCamera.html#zNearCoefficient()"><CODE>zNearCoefficient()</CODE></A> value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="zClippingCoefficient()"><!-- --></A><H3>
zClippingCoefficient</H3>
<PRE>
public float <B>zClippingCoefficient</B>()</PRE>
<DL>
<DD>Returns the coefficient used to position the near and far clipping
 planes. 
 <p> 
 The near (resp. far) clipping plane is positioned at a distance equal to
 <code>zClippingCoefficient() * sceneRadius()</code> in front of (resp. behind)
 the <A HREF="../proscene/PSCamera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A>. This guarantees an optimal use of the
 z-buffer range and minimizes aliasing. See the <A HREF="../proscene/PSCamera.html#zNear()"><CODE>zNear()</CODE></A> and
 <A HREF="../proscene/PSCamera.html#zFar()"><CODE>zFar()</CODE></A> documentations. 
 <p> 
 Default value is square root of 3.0 (so that a cube of size
 <A HREF="../proscene/PSCamera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> is not clipped). 
 <p> 
 However, since the <A HREF="../proscene/PSCamera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> is used for other purposes (see
 showEntireScene(), flySpeed(), ...) and you may want to change this value
 to define more precisely the location of the clipping planes. See also
 <A HREF="../proscene/PSCamera.html#zNearCoefficient()"><CODE>zNearCoefficient()</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setZClippingCoefficient(float)"><!-- --></A><H3>
setZClippingCoefficient</H3>
<PRE>
public void <B>setZClippingCoefficient</B>(float&nbsp;coef)</PRE>
<DL>
<DD>Sets the <A HREF="../proscene/PSCamera.html#zClippingCoefficient()"><CODE>zClippingCoefficient()</CODE></A> value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="pixelPSRatio(processing.core.PVector)"><!-- --></A><H3>
pixelPSRatio</H3>
<PRE>
public float <B>pixelPSRatio</B>(processing.core.PVector&nbsp;position)</PRE>
<DL>
<DD>Returns the ratio between pixel and processing scene units at <code>position</code>. 
 <p> 
 A line of <code>n * pixelPSRatio()</code> processing scene units, located at <code>position</code> in
 the world coordinates system, will be projected with a length of <code>n</code> pixels on screen. 
 <p> 
 Use this method to scale objects so that they have a constant pixel size on screen.
 The following code will draw a 20 pixel line, starting at <A HREF="../proscene/PSCamera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A> and
 always directed along the screen vertical direction:
 <p>
 <code>beginShape(LINES);</code><br>
 <code>vertex(sceneCenter().x, sceneCenter().y, sceneCenter().z);</code><br>
 <code>PVector v = PVector.add(sceneCenter(), PVector.mult(upVector(), 20 * pixelPSRatio(sceneCenter())));</code><br>
 <code>vertex(v.x, v.y, v.z);</code><br>
 <code>endShape();</code><br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sceneRadius()"><!-- --></A><H3>
sceneRadius</H3>
<PRE>
public float <B>sceneRadius</B>()</PRE>
<DL>
<DD>Returns the radius of the scene observed by the Camera. 
 <p> 
 You need to provide such an approximation of the scene dimensions so that
 the Camera can adapt its <A HREF="../proscene/PSCamera.html#zNear()"><CODE>zNear()</CODE></A> and <A HREF="../proscene/PSCamera.html#zFar()"><CODE>zFar()</CODE></A> values. See the
 <A HREF="../proscene/PSCamera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A> documentation. 
 <p> 
 Note that PScene.sceneRadius() (resp. PScene.setSceneRadius()) simply call this
 method on its associated PSCamera.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../proscene/PSCamera.html#setSceneBoundingBox(processing.core.PVector, processing.core.PVector)"><CODE>setSceneBoundingBox(PVector, PVector)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setSceneRadius(float)"><!-- --></A><H3>
setSceneRadius</H3>
<PRE>
public void <B>setSceneRadius</B>(float&nbsp;radius)</PRE>
<DL>
<DD>Sets the <A HREF="../proscene/PSCamera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> value. Negative values are ignored. 
 <p> 
 <b>Attention:</b> This methods also sets <A HREF="../proscene/PSCamera.html#focusDistance()"><CODE>focusDistance()</CODE></A> to
 <code>sceneRadius() / tan(fieldOfView()/2)</code> and <A HREF="../proscene/PSCamera.html#flySpeed()"><CODE>flySpeed()</CODE></A> to
 1% of <A HREF="../proscene/PSCamera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sceneCenter()"><!-- --></A><H3>
sceneCenter</H3>
<PRE>
public processing.core.PVector <B>sceneCenter</B>()</PRE>
<DL>
<DD>Returns the position of the scene center, defined in the world coordinate
 system. 
 <p> 
 The scene observed by the PSCamera should be roughly centered on this
 position, and included in a <A HREF="../proscene/PSCamera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> sphere. This approximate
 description of the scene permits a <A HREF="../proscene/PSCamera.html#zNear()"><CODE>zNear()</CODE></A> and <A HREF="../proscene/PSCamera.html#zFar()"><CODE>zFar()</CODE></A>
 clipping planes definition, and allows convenient positioning methods such as
 <A HREF="../proscene/PSCamera.html#showEntireScene()"><CODE>showEntireScene()</CODE></A>. 
 <p> 
 Note that <A HREF="../proscene/PScene.html#sceneCenter()"><CODE>PScene.sceneCenter()</CODE></A> (resp.
 proscene.PScene<A HREF="../proscene/PSCamera.html#setSceneCenter(processing.core.PVector)"><CODE>setSceneCenter(PVector)</CODE></A>)
 simply call this method (resp. <A HREF="../proscene/PSCamera.html#setSceneCenter(processing.core.PVector)"><CODE>setSceneCenter(PVector)</CODE></A>) on its associated
 <A HREF="../proscene/PScene.html#camera()"><CODE>PScene.camera()</CODE></A>. Default value is (0,0,0) (world origin). Use
 <A HREF="../proscene/PSCamera.html#setSceneCenter(processing.core.PVector)"><CODE>setSceneCenter(PVector)</CODE></A> to change it.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../proscene/PSCamera.html#setSceneBoundingBox(processing.core.PVector, processing.core.PVector)"><CODE>setSceneBoundingBox(PVector, PVector)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setSceneCenter(processing.core.PVector)"><!-- --></A><H3>
setSceneCenter</H3>
<PRE>
public void <B>setSceneCenter</B>(processing.core.PVector&nbsp;center)</PRE>
<DL>
<DD>Sets the <A HREF="../proscene/PSCamera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A>. 
 <p> 
 <b>Attention:</b> This method also sets the <A HREF="../proscene/PSCamera.html#revolveAroundPoint()"><CODE>revolveAroundPoint()</CODE></A>
 to <A HREF="../proscene/PSCamera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="distanceToSceneCenter()"><!-- --></A><H3>
distanceToSceneCenter</H3>
<PRE>
public float <B>distanceToSceneCenter</B>()</PRE>
<DL>
<DD>Returns the distance from the Camera center to <A HREF="../proscene/PSCamera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A>, projected
 along the Camera Z axis. 
 <p> 
 Used by <A HREF="../proscene/PSCamera.html#zNear()"><CODE>zNear()</CODE></A> and <A HREF="../proscene/PSCamera.html#zFar()"><CODE>zFar()</CODE></A> to optimize the Z range.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setSceneBoundingBox(processing.core.PVector, processing.core.PVector)"><!-- --></A><H3>
setSceneBoundingBox</H3>
<PRE>
public void <B>setSceneBoundingBox</B>(processing.core.PVector&nbsp;min,
                                processing.core.PVector&nbsp;max)</PRE>
<DL>
<DD>Similar to <A HREF="../proscene/PSCamera.html#setSceneRadius(float)"><CODE>setSceneRadius(float)</CODE></A> and
 <A HREF="../proscene/PSCamera.html#setSceneCenter(processing.core.PVector)"><CODE>setSceneCenter(PVector)</CODE></A>, but the scene limits are defined by a
 (world axis aligned) bounding box.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="revolveAroundPoint()"><!-- --></A><H3>
revolveAroundPoint</H3>
<PRE>
public final processing.core.PVector <B>revolveAroundPoint</B>()</PRE>
<DL>
<DD>The point the PSCamera revolves around its
 <A HREF="../proscene/PSInteractiveCameraFrame.html#revolveAroundPoint()"><CODE>PSInteractiveCameraFrame.revolveAroundPoint()</CODE></A>. 
 <p> 
 Default value is the <A HREF="../proscene/PSCamera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A>. 
 <p> 
 <b>Attention:</b> <A HREF="../proscene/PSCamera.html#setSceneCenter(processing.core.PVector)"><CODE>setSceneCenter(PVector)</CODE></A> changes this value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setRevolveAroundPoint(processing.core.PVector)"><!-- --></A><H3>
setRevolveAroundPoint</H3>
<PRE>
public void <B>setRevolveAroundPoint</B>(processing.core.PVector&nbsp;rap)</PRE>
<DL>
<DD>Changes the <A HREF="../proscene/PSCamera.html#revolveAroundPoint()"><CODE>revolveAroundPoint()</CODE></A> to <code>rap</code> (defined in the
 world coordinate system).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="frame()"><!-- --></A><H3>
frame</H3>
<PRE>
public <A HREF="../proscene/PSInteractiveCameraFrame.html" title="class in proscene">PSInteractiveCameraFrame</A> <B>frame</B>()</PRE>
<DL>
<DD>Returns the PSInteractiveCameraFrame attached to the PSCamera. 
 <p> 
 This PSInteractiveCameraFrame defines its <A HREF="../proscene/PSCamera.html#position()"><CODE>position()</CODE></A> and
 <A HREF="../proscene/PSCamera.html#orientation()"><CODE>orientation()</CODE></A> and can translate mouse events into PSCamera
 displacement. Set using <A HREF="../proscene/PSCamera.html#setFrame(proscene.PSInteractiveCameraFrame)"><CODE>setFrame(PSInteractiveCameraFrame)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setFrame(proscene.PSInteractiveCameraFrame)"><!-- --></A><H3>
setFrame</H3>
<PRE>
public final void <B>setFrame</B>(<A HREF="../proscene/PSInteractiveCameraFrame.html" title="class in proscene">PSInteractiveCameraFrame</A>&nbsp;icf)</PRE>
<DL>
<DD>Sets the PSCamera <A HREF="../proscene/PSCamera.html#frame()"><CODE>frame()</CODE></A>. 
 <p> 
 If you want to move the PSCamera, use <A HREF="../proscene/PSCamera.html#setPosition(processing.core.PVector)"><CODE>setPosition(PVector)</CODE></A> and
 <A HREF="../proscene/PSCamera.html#setOrientation(proscene.PSQuaternion)"><CODE>setOrientation(PSQuaternion)</CODE></A> or one of the PSCamera positioning
 methods (<A HREF="../proscene/PSCamera.html#lookAt(processing.core.PVector)"><CODE>lookAt(PVector)</CODE></A>, <A HREF="../proscene/PSCamera.html#fitSphere(processing.core.PVector, float)"><CODE>fitSphere(PVector, float)</CODE></A>,
 <A HREF="../proscene/PSCamera.html#showEntireScene()"><CODE>showEntireScene()</CODE></A>...) instead.
 <p> 
 This method is actually mainly useful if you derive the
 PSInteractiveCameraFrame class and want to use an instance of your new
 class to move the PSCamera. 
 <p> 
 A <code>null</code> <code>icf</code> reference will silently be ignored.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getProjectionMatrix()"><!-- --></A><H3>
getProjectionMatrix</H3>
<PRE>
public processing.core.PMatrix3D <B>getProjectionMatrix</B>()</PRE>
<DL>
<DD>Convenience function that simply returns <code>return return getProjectionMatrix(new PMatrix3D())</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../proscene/PSCamera.html#getProjectionMatrix(processing.core.PMatrix3D)"><CODE>getProjectionMatrix(PMatrix3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getProjectionMatrix(processing.core.PMatrix3D)"><!-- --></A><H3>
getProjectionMatrix</H3>
<PRE>
public processing.core.PMatrix3D <B>getProjectionMatrix</B>(processing.core.PMatrix3D&nbsp;m)</PRE>
<DL>
<DD>Fills <code>m</code> with the PSCamera projection matrix values and returns it. If
 <code>m</code> is <code>null</code> a new PMatrix3D will be created. 
 <p> 
 Calls <A HREF="../proscene/PSCamera.html#computeProjectionMatrix()"><CODE>computeProjectionMatrix()</CODE></A> to define the PSCamera projection matrix.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../proscene/PSCamera.html#getModelViewMatrix()"><CODE>getModelViewMatrix()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="computeProjectionMatrix()"><!-- --></A><H3>
computeProjectionMatrix</H3>
<PRE>
public void <B>computeProjectionMatrix</B>()</PRE>
<DL>
<DD>Computes the projection matrix associated with the PSCamera. 
 <p> 
 If <A HREF="../proscene/PSCamera.html#type()"><CODE>type()</CODE></A> is PERSPECTIVE, defines a GL_PROJECTION matrix similar to what
 would <code>perspective()</code> do using the <A HREF="../proscene/PSCamera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A>, window
 <A HREF="../proscene/PSCamera.html#aspectRatio()"><CODE>aspectRatio()</CODE></A>, <A HREF="../proscene/PSCamera.html#zNear()"><CODE>zNear()</CODE></A> and <A HREF="../proscene/PSCamera.html#zFar()"><CODE>zFar()</CODE></A> parameters. 
 <p> 
 If <A HREF="../proscene/PSCamera.html#type()"><CODE>type()</CODE></A> is ORTHOGRAPHIC, the projection matrix is as what <code>ortho()</code> would do. Frustum's width and height are set using
 <A HREF="../proscene/PSCamera.html#getOrthoWidthHeight()"><CODE>getOrthoWidthHeight()</CODE></A>. 
 <p> 
 Both types use <A HREF="../proscene/PSCamera.html#zNear()"><CODE>zNear()</CODE></A> and <A HREF="../proscene/PSCamera.html#zFar()"><CODE>zFar()</CODE></A> to place clipping planes. These values
 are determined from sceneRadius() and sceneCenter() so that they best fit
 the scene size. 
 <p> 
 Use <A HREF="../proscene/PSCamera.html#getProjectionMatrix()"><CODE>getProjectionMatrix()</CODE></A> to retrieve this matrix.
 <p> 
 <b>Note:</b> You must call this method if your PSCamera is not associated
 with a PScene and is used for offscreen computations
 (using <code>projectedCoordinatesOf()</code> for instance).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../proscene/PSCamera.html#setProjectionMatrix(processing.core.PMatrix3D)"><CODE>setProjectionMatrix(PMatrix3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setProjectionMatrix(processing.core.PMatrix3D)"><!-- --></A><H3>
setProjectionMatrix</H3>
<PRE>
public void <B>setProjectionMatrix</B>(processing.core.PMatrix3D&nbsp;proj)</PRE>
<DL>
<DD>Sets the projection matrix associated with the PSCamera directly from a PCamera.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../proscene/PSCamera.html#computeProjectionMatrix()"><CODE>computeProjectionMatrix()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getModelViewMatrix()"><!-- --></A><H3>
getModelViewMatrix</H3>
<PRE>
public processing.core.PMatrix3D <B>getModelViewMatrix</B>()</PRE>
<DL>
<DD>Convenience function that simply returns
 <code>return getModelViewMatrix(new PMatrix3D())</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getModelViewMatrix(processing.core.PMatrix3D)"><!-- --></A><H3>
getModelViewMatrix</H3>
<PRE>
public processing.core.PMatrix3D <B>getModelViewMatrix</B>(processing.core.PMatrix3D&nbsp;m)</PRE>
<DL>
<DD>Fills <code>m</code> with the Camera modelView matrix values and returns it. If
 <code>m</code> is <code>null</code> a new PMatrix3D will be created.
 <p> 
 First calls <A HREF="../proscene/PSCamera.html#computeModelViewMatrix()"><CODE>computeModelViewMatrix()</CODE></A> to define the PSCamera modelView matrix.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../proscene/PSCamera.html#getProjectionMatrix(processing.core.PMatrix3D)"><CODE>getProjectionMatrix(PMatrix3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="computeModelViewMatrix()"><!-- --></A><H3>
computeModelViewMatrix</H3>
<PRE>
public void <B>computeModelViewMatrix</B>()</PRE>
<DL>
<DD>Computes the modelView matrix associated with the Camera's <A HREF="../proscene/PSCamera.html#position()"><CODE>position()</CODE></A>
 and <A HREF="../proscene/PSCamera.html#orientation()"><CODE>orientation()</CODE></A>.
 <p> 
 This matrix converts from the world coordinates system to the PSCamera
 coordinates system, so that coordinates can then be projected on screen
 using the projection matrix (see <A HREF="../proscene/PSCamera.html#computeProjectionMatrix()"><CODE>computeProjectionMatrix()</CODE></A>).
 <p>
 Use <A HREF="../proscene/PSCamera.html#getModelViewMatrix()"><CODE>getModelViewMatrix()</CODE></A> to retrieve this matrix.
 <p> 
 <b>Note:</b> You must call this method if your PSCamera is not associated with a
 PScene and is used for offscreen computations
 (using <code>projectedCoordinatesOf()</code> for instance).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setModelViewMatrix(processing.core.PMatrix3D)"><!-- --></A><H3>
setModelViewMatrix</H3>
<PRE>
public void <B>setModelViewMatrix</B>(processing.core.PMatrix3D&nbsp;modelview)</PRE>
<DL>
<DD>Sets the modelview matrix associated with the PSCamera directly from a PCamera.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../proscene/PSCamera.html#computeModelViewMatrix()"><CODE>computeModelViewMatrix()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cameraCoordinatesOf(processing.core.PVector)"><!-- --></A><H3>
cameraCoordinatesOf</H3>
<PRE>
public final processing.core.PVector <B>cameraCoordinatesOf</B>(processing.core.PVector&nbsp;src)</PRE>
<DL>
<DD>Returns the PSCamera frame coordinates of a point <code>src</code> defined in
 world coordinates. 
 <p> 
 <A HREF="../proscene/PSCamera.html#worldCoordinatesOf(processing.core.PVector)"><CODE>worldCoordinatesOf(PVector)</CODE></A> performs the inverse transformation. 
 <p> 
 Note that the point coordinates are simply converted in a different
 coordinate system. They are not projected on screen. Use
 <A HREF="../proscene/PSCamera.html#projectedCoordinatesOf(processing.core.PVector, proscene.PSFrame)"><CODE>projectedCoordinatesOf(PVector, PSFrame)</CODE></A> for that.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="worldCoordinatesOf(processing.core.PVector)"><!-- --></A><H3>
worldCoordinatesOf</H3>
<PRE>
public processing.core.PVector <B>worldCoordinatesOf</B>(processing.core.PVector&nbsp;src)</PRE>
<DL>
<DD>Returns the world coordinates of the point whose position <code>src</code> is
 defined in the PSCamera coordinate system. 
 <p> 
 <A HREF="../proscene/PSCamera.html#cameraCoordinatesOf(processing.core.PVector)"><CODE>cameraCoordinatesOf(PVector)</CODE></A> performs the inverse
 transformation.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="convertClickToLine(java.awt.Point, processing.core.PVector, processing.core.PVector)"><!-- --></A><H3>
convertClickToLine</H3>
<PRE>
public void <B>convertClickToLine</B>(java.awt.Point&nbsp;pixelInput,
                               processing.core.PVector&nbsp;orig,
                               processing.core.PVector&nbsp;dir)</PRE>
<DL>
<DD>Gives the coefficients of a 3D half-line passing through the PSCamera eye
 and pixel (x,y). 
 <p> 
 The origin of the half line (eye position) is stored in <code>orig</code>,
 while <code>dir</code> contains the properly oriented and normalized direction
 of the half line. 
 <p> 
 <code>x</code> and <code>y</code> are expressed in Processing format (origin in the
 upper left corner). Use <A HREF="../proscene/PSCamera.html#screenHeight()"><CODE>screenHeight()</CODE></A> - y to convert to processing scene units. 
 <p> 
 This method is useful for analytical intersection in a selection method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="projectedCoordinatesOf(processing.core.PVector)"><!-- --></A><H3>
projectedCoordinatesOf</H3>
<PRE>
public final processing.core.PVector <B>projectedCoordinatesOf</B>(processing.core.PVector&nbsp;src)</PRE>
<DL>
<DD>Convenience function that simply returns <code>return
 projectedCoordinatesOf(src, null)</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="projectedCoordinatesOf(processing.core.PVector, proscene.PSFrame)"><!-- --></A><H3>
projectedCoordinatesOf</H3>
<PRE>
public final processing.core.PVector <B>projectedCoordinatesOf</B>(processing.core.PVector&nbsp;src,
                                                            <A HREF="../proscene/PSFrame.html" title="class in proscene">PSFrame</A>&nbsp;frame)</PRE>
<DL>
<DD>Returns the screen projected coordinates of a point <code>src</code> defined
 in the <code>frame</code> coordinate system. 
 <p> 
 When <code>frame</code> is <code>null</code>, <code>src</code> is expressed in the world
 coordinate system. See <A HREF="../proscene/PSCamera.html#projectedCoordinatesOf(processing.core.PVector)"><CODE>projectedCoordinatesOf(PVector)</CODE></A>. 
 <p> 
 The x and y coordinates of the returned PVector are expressed in pixel,
 (0,0) being the upper left corner of the window. The z coordinate ranges
 between 0.0 (near plane) and 1.0 (excluded, far plane). See the <code>gluProject</code> man page for details.
 <b>Attention:</b> This method only uses the intrinsic PSCamera parameters
 (see <A HREF="../proscene/PSCamera.html#getModelViewMatrix()"><CODE>getModelViewMatrix()</CODE></A>, <A HREF="../proscene/PSCamera.html#getProjectionMatrix()"><CODE>getProjectionMatrix()</CODE></A> and
 <A HREF="../proscene/PSCamera.html#getViewport()"><CODE>getViewport()</CODE></A>) and is completely independent of the processing
 matrices. You can hence define a virtual PSCamera and use this method to
 compute projections out of a classical rendering context.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="flySpeed()"><!-- --></A><H3>
flySpeed</H3>
<PRE>
public float <B>flySpeed</B>()</PRE>
<DL>
<DD>Returns the fly speed of the PSCamera. 
 <p> 
 Simply returns <code>frame().flySpeed()</code>. See the
 <A HREF="../proscene/PSInteractiveCameraFrame.html#flySpeed()"><CODE>PSInteractiveCameraFrame.flySpeed()</CODE></A>
 documentation. This value is only meaningful when the MouseAction
 bindings is PScene.MOVE_FORWARD or is PScene.MOVE_BACKWARD.
 <p>
 Set to 0.5% of the <A HREF="../proscene/PSCamera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> by
 <A HREF="../proscene/PSCamera.html#setSceneRadius(float)"><CODE>setSceneRadius(float)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../proscene/PSCamera.html#setFlySpeed(float)"><CODE>setFlySpeed(float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setFlySpeed(float)"><!-- --></A><H3>
setFlySpeed</H3>
<PRE>
public void <B>setFlySpeed</B>(float&nbsp;speed)</PRE>
<DL>
<DD>Sets the PSCamera <A HREF="../proscene/PSCamera.html#flySpeed()"><CODE>flySpeed()</CODE></A>.
 <p>
 <b>Attention:</b> This value is modified by
 <A HREF="../proscene/PSCamera.html#setSceneRadius(float)"><CODE>setSceneRadius(float)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lookAt(processing.core.PVector)"><!-- --></A><H3>
lookAt</H3>
<PRE>
public void <B>lookAt</B>(processing.core.PVector&nbsp;target)</PRE>
<DL>
<DD>Sets the PSCamera <A HREF="../proscene/PSCamera.html#orientation()"><CODE>orientation()</CODE></A>, so that it looks at point
 <code>target</code> (defined in the world coordinate system). 
 <p> 
 The Camera <A HREF="../proscene/PSCamera.html#position()"><CODE>position()</CODE></A> is not modified. Simply
 <A HREF="../proscene/PSCamera.html#setViewDirection(processing.core.PVector)"><CODE>setViewDirection(PVector)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../proscene/PSCamera.html#at()"><CODE>at()</CODE></A>, 
<A HREF="../proscene/PSCamera.html#setUpVector(processing.core.PVector)"><CODE>setUpVector(PVector)</CODE></A>, 
<A HREF="../proscene/PSCamera.html#setOrientation(proscene.PSQuaternion)"><CODE>setOrientation(PSQuaternion)</CODE></A>, 
<A HREF="../proscene/PSCamera.html#showEntireScene()"><CODE>showEntireScene()</CODE></A>, 
<A HREF="../proscene/PSCamera.html#fitSphere(processing.core.PVector, float)"><CODE>fitSphere(PVector, float)</CODE></A>, 
<A HREF="../proscene/PSCamera.html#fitBoundingBox(processing.core.PVector, processing.core.PVector)"><CODE>fitBoundingBox(PVector, PVector)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="at()"><!-- --></A><H3>
at</H3>
<PRE>
public processing.core.PVector <B>at</B>()</PRE>
<DL>
<DD>Returns a point defined in the world coordinate system where the camera is
 pointing at (just in front of <A HREF="../proscene/PSCamera.html#viewDirection()"><CODE>viewDirection()</CODE></A>). Useful for setting the
 Processing camera() which uses a similar approach of that found in gluLookAt.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../proscene/PSCamera.html#lookAt(processing.core.PVector)"><CODE>lookAt(PVector)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="fitSphere(processing.core.PVector, float)"><!-- --></A><H3>
fitSphere</H3>
<PRE>
public void <B>fitSphere</B>(processing.core.PVector&nbsp;center,
                      float&nbsp;radius)</PRE>
<DL>
<DD>Moves the PSCamera so that the sphere defined by <code>center</code>, <code>radius</code>) is visible and fits the window. 
 <p> 
 The PSCamera is simply translated along its <A HREF="../proscene/PSCamera.html#viewDirection()"><CODE>viewDirection()</CODE></A> so
 that the sphere fits the screen. Its <A HREF="../proscene/PSCamera.html#orientation()"><CODE>orientation()</CODE></A> and its
 <A HREF="../proscene/PSCamera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A> are unchanged. 
 <p> 
 You should therefore orientate the PSCamera before you call this method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../proscene/PSCamera.html#lookAt(processing.core.PVector)"><CODE>lookAt(PVector)</CODE></A>, 
<A HREF="../proscene/PSCamera.html#setOrientation(proscene.PSQuaternion)"><CODE>setOrientation(PSQuaternion)</CODE></A>, 
<A HREF="../proscene/PSCamera.html#setUpVector(processing.core.PVector, boolean)"><CODE>setUpVector(PVector, boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="fitBoundingBox(processing.core.PVector, processing.core.PVector)"><!-- --></A><H3>
fitBoundingBox</H3>
<PRE>
public void <B>fitBoundingBox</B>(processing.core.PVector&nbsp;min,
                           processing.core.PVector&nbsp;max)</PRE>
<DL>
<DD>Moves the PSCamera so that the (world axis aligned) bounding box (<code>min</code>, <code>max</code>) is entirely visible, using
 <A HREF="../proscene/PSCamera.html#fitSphere(processing.core.PVector, float)"><CODE>fitSphere(PVector, float)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="fitScreenRegion(java.awt.Rectangle)"><!-- --></A><H3>
fitScreenRegion</H3>
<PRE>
public void <B>fitScreenRegion</B>(java.awt.Rectangle&nbsp;rectangle)</PRE>
<DL>
<DD>Moves the PSCamera so that the rectangular screen region defined by <code>rectangle</code> (pixel units, with origin in the upper left corner) fits the
 screen. 
 <p> 
 The PSCamera is translated (its orientation() is unchanged) so that
 <code>rectangle</code> is entirely visible. Since the pixel coordinates only
 define a <i>frustum</i> in 3D, it's the intersection of this frustum with
 a plane (orthogonal to the viewDirection() and passing through the
 sceneCenter()) that is used to define the 3D rectangle that is eventually
 fitted.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="showEntireScene()"><!-- --></A><H3>
showEntireScene</H3>
<PRE>
public void <B>showEntireScene</B>()</PRE>
<DL>
<DD>Moves the PSCamera so that the entire scene is visible. 
 <p> 
 Simply calls <A HREF="../proscene/PSCamera.html#fitSphere(processing.core.PVector, float)"><CODE>fitSphere(PVector, float)</CODE></A> on a sphere defined by
 <A HREF="../proscene/PSCamera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A> and <A HREF="../proscene/PSCamera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A>. 
 <p> 
 You will typically use this method in <A HREF="../proscene/PScene.html#init()"><CODE>PScene.init()</CODE></A> after you defined
 a new <A HREF="../proscene/PSCamera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="centerScene()"><!-- --></A><H3>
centerScene</H3>
<PRE>
public void <B>centerScene</B>()</PRE>
<DL>
<DD>Moves the PSCamera so that its <A HREF="../proscene/PSCamera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A> is projected on the
 center of the window. The <A HREF="../proscene/PSCamera.html#orientation()"><CODE>orientation()</CODE></A> and
 <A HREF="../proscene/PSCamera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A> are unchanged. 
 <p> 
 Simply projects the current position on a line passing through
 <A HREF="../proscene/PSCamera.html#sceneCenter()"><CODE>sceneCenter()</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../proscene/PSCamera.html#showEntireScene()"><CODE>showEntireScene()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="IODistance()"><!-- --></A><H3>
IODistance</H3>
<PRE>
public float <B>IODistance</B>()</PRE>
<DL>
<DD>Returns the user's inter-ocular distance (in meters). Default value is
 0.062m, which fits most people.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../proscene/PSCamera.html#setIODistance(float)"><CODE>setIODistance(float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setIODistance(float)"><!-- --></A><H3>
setIODistance</H3>
<PRE>
public void <B>setIODistance</B>(float&nbsp;distance)</PRE>
<DL>
<DD>Sets the <A HREF="../proscene/PSCamera.html#IODistance()"><CODE>IODistance()</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="physicalDistanceToScreen()"><!-- --></A><H3>
physicalDistanceToScreen</H3>
<PRE>
public float <B>physicalDistanceToScreen</B>()</PRE>
<DL>
<DD>Returns the physical distance between the user's eyes and the screen (in
 meters). 
 <p> 
 Default value is 0.5m. 
 <p>
 Value is set using <A HREF="../proscene/PSCamera.html#setPhysicalDistanceToScreen(float)"><CODE>setPhysicalDistanceToScreen(float)</CODE></A>. 
 <p> 
 physicalDistanceToScreen() and <A HREF="../proscene/PSCamera.html#focusDistance()"><CODE>focusDistance()</CODE></A> represent the same
 distance. The first one is expressed in physical real world units, while
 the latter is expressed in processing virtual world units. Use their ratio to
 convert distances between these worlds.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setPhysicalDistanceToScreen(float)"><!-- --></A><H3>
setPhysicalDistanceToScreen</H3>
<PRE>
public void <B>setPhysicalDistanceToScreen</B>(float&nbsp;distance)</PRE>
<DL>
<DD>Sets the <A HREF="../proscene/PSCamera.html#physicalDistanceToScreen()"><CODE>physicalDistanceToScreen()</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="physicalScreenWidth()"><!-- --></A><H3>
physicalScreenWidth</H3>
<PRE>
public float <B>physicalScreenWidth</B>()</PRE>
<DL>
<DD>Returns the physical screen width, in meters. Default value is 0.4m
 (average monitor). 
 <p> 
 Used for stereo display only. Set using
 <A HREF="../proscene/PSCamera.html#setPhysicalScreenWidth(float)"><CODE>setPhysicalScreenWidth(float)</CODE></A>.
 <p>
 See <A HREF="../proscene/PSCamera.html#physicalDistanceToScreen()"><CODE>physicalDistanceToScreen()</CODE></A> for reality center automatic
 configuration.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setPhysicalScreenWidth(float)"><!-- --></A><H3>
setPhysicalScreenWidth</H3>
<PRE>
public void <B>setPhysicalScreenWidth</B>(float&nbsp;width)</PRE>
<DL>
<DD>Sets the physical screen (monitor or projected wall) width (in meters).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="focusDistance()"><!-- --></A><H3>
focusDistance</H3>
<PRE>
public float <B>focusDistance</B>()</PRE>
<DL>
<DD>Returns the focus distance used by stereo display, expressed in processing
 units. 
 <p> 
 This is the distance in the virtual world between the Camera and the
 plane where the horizontal stereo parallax is null (the stereo left and
 right images are superimposed). 
 <p> 
 This distance is the virtual world equivalent of the real-world
 <A HREF="../proscene/PSCamera.html#physicalDistanceToScreen()"><CODE>physicalDistanceToScreen()</CODE></A>. 
 <p> 
 <b>attention:</b> This value is modified by PScene.setSceneRadius(),
 setSceneRadius() and <A HREF="../proscene/PSCamera.html#setFieldOfView(float)"><CODE>setFieldOfView(float)</CODE></A>. When one of these
 values is modified, <A HREF="../proscene/PSCamera.html#focusDistance()"><CODE>focusDistance()</CODE></A> is set to
 <A HREF="../proscene/PSCamera.html#sceneRadius()"><CODE>sceneRadius()</CODE></A> / tan(<A HREF="../proscene/PSCamera.html#fieldOfView()"><CODE>fieldOfView()</CODE></A>/2), which provides
 good results.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setFocusDistance(float)"><!-- --></A><H3>
setFocusDistance</H3>
<PRE>
public void <B>setFocusDistance</B>(float&nbsp;distance)</PRE>
<DL>
<DD>Sets the focusDistance(), in processing scene units.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../proscene/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../proscene/PSAxisPlaneConstraint.Type.html" title="enum in proscene"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../proscene/PSCamera.Type.html" title="enum in proscene"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?proscene/PSCamera.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="PSCamera.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
processing library proscene by Jean Pierre Charalambos. (c) 2010
</BODY>
</HTML>
