#summary Describes how to use an HIDevice

=How to use a [http://en.wikipedia.org/wiki/Human_interface_device HIDevice]?=

Suppose that we wish to control our camera and some objects in our *scene* using a [http://en.wikipedia.org/wiki/6DOF 6-DOF] device such the [http://en.wikipedia.org/wiki/Space_navigator 3d space navigator]. We do it by declaring an *HIDevice* and "feed" it with the output generated by the physical device reported by a third party hardware controller. Once we instantiate an *HIDevice*, say `dev`, we can cycle to the predefined camera and frame configurations calling `dev.nextCameraMode()` and `dev.nextIFrameMode()`, respectively.

To instantiate and define an *HIDevice* we have the following two options (in the code snippets below *note* that the `slider*pos` and the `slider*rot` objects belong to the third party library actually controlling the hardware):

===Option 1: Declare your own HIDevice and add a feed handler ===

{{{
void setup() {
  ...
  scene = new Scene(this);//declare the scene, which is the main Proscene object
  dev = new HIDevice(scene);//declare a RELATIVE mode HIDevice
  dev.addHandler(this, "feed");//add the feed defined below
  //Define the translation sensitivities
  //(0 will disable the translation, a negative value will reverse its direction)
  dev.setTranslationSensitivity(0.01f, 0.01f, 0.01f);
  //Define the translation sensitivities
  //(0 will disable the rotation, a negative value will reverse its orientation)
  dev.setRotationSensitivity(0.0001f, 0.0001f, 0.0001f);
  scene.addDevice(dev);
}
//The feed handler function should look like the following:
void feed(HIDevice d) {
  //enable the three translations
  //again, 0 will disable the translation, a negative value will reverse its direction
  //to produce a different mapping between the device axes and the different scene coordinates systems' axes
  //(referred to in proscene as Frames) simply exchange the order of the slider*pos parameters at will.
  d.feedTranslation(sliderXpos.getValue(), sliderYpos.getValue(), sliderZpos.getValue());
  //enable the three rotations
  //again, 0 will disable the rotation, a negative value will reverse its orientation
  //to produce a different mapping between the device axes and the different scene frames'
  //axes simply exchange the order of the slider*pos parameters at will.
  d.feedRotation(sliderXrot.getValue(), sliderYrot.getValue(), sliderZrot.getValue());
}
}}}

===Option 2: Declare your own HIDevice derived class and override the feeds===

The following code will handle the device exactly as in the previous option.

{{{
void setup() {
  ...
  scene = new Scene(this);//declare the scene, which is the main Proscene object
  //declare your own HIDevice derived class
  dev = new HIDevice(scene) {
    //if one of the feeds is not overridden the correspondent translation/rotation would be disabled 
    public float feedXTranslation() {
      return sliderXpos.getValue();
    }
    public float feedYTranslation() {
      return sliderYpos.getValue();
    }
    public float feedZTranslation() {
      return sliderZpos.getValue();
    }
    public float feedXRotation() {
      return sliderXrot.getValue();
    }
    public float feedYRotation() {
      return sliderYrot.getValue();
    }
    public float feedZRotation() {
      return sliderZrot.getValue();
    }
  };
  //Define the translation sensitivities
  //(0 will disable the translation, a negative value will reverse its direction)
  dev.setTranslationSensitivity(0.01f, 0.01f, 0.01f);
  //Define the translation sensitivities
  //(0 will disable the rotation, a negative value will reverse its orientation)
  dev.setRotationSensitivity(0.0001f, 0.0001f, 0.0001f);
  scene.addDevice(dev);
}
}}}

==Observations:==

 # *Proscene* does not handle the device directly. This should be achieved  with a third party library such [http://www.creativecomputing.cc/p5libs/procontroll/ procontroll].
 # An *HIDevice* implements some default configurations to manipulate the camera and a given interactive frame. A third party configuration can easily be implemented too (see the *HIDevice* API for details). *If you implement your own configuration and wish to share please let us know. If you want us to implement a new one, let us know it too :)*
 # There are three new examples that illustrate how to instantiate and use an *HIDevice*: *!SpaceNavigator*, *HIDeviceSingleViewer*, and *HIDeviceMultiViewer*. The three examples require a space navigator and while the first one should make it to the final release the latter two are provided only for testing purposes.
 # These three examples have been tested in Ubuntu and Windows using *procontroll* but they only work in Windows. This has to do with a *procontroll* issue (I already contacted its developers to try to solve it). Testing them in Mac still requires to be done. *Feedback is more than welcome*!
 # If you implement support for another device *please let us know*. For instance we'd love to see support for the kinect in the near future. We just don't have one to play around at the time ;)